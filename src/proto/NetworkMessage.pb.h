// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NetworkMessage.proto

#ifndef PROTOBUF_INCLUDED_NetworkMessage_2eproto
#define PROTOBUF_INCLUDED_NetworkMessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_NetworkMessage_2eproto 

namespace protobuf_NetworkMessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_NetworkMessage_2eproto
class HeartbeatMessage;
class HeartbeatMessageDefaultTypeInternal;
extern HeartbeatMessageDefaultTypeInternal _HeartbeatMessage_default_instance_;
class NetworkMessage;
class NetworkMessageDefaultTypeInternal;
extern NetworkMessageDefaultTypeInternal _NetworkMessage_default_instance_;
class PlayerAttributeMessage;
class PlayerAttributeMessageDefaultTypeInternal;
extern PlayerAttributeMessageDefaultTypeInternal _PlayerAttributeMessage_default_instance_;
class PlayerAttributeMessage_AmmoEntry_DoNotUse;
class PlayerAttributeMessage_AmmoEntry_DoNotUseDefaultTypeInternal;
extern PlayerAttributeMessage_AmmoEntry_DoNotUseDefaultTypeInternal _PlayerAttributeMessage_AmmoEntry_DoNotUse_default_instance_;
class PlayerAttributeMessage_WeaponsEntry_DoNotUse;
class PlayerAttributeMessage_WeaponsEntry_DoNotUseDefaultTypeInternal;
extern PlayerAttributeMessage_WeaponsEntry_DoNotUseDefaultTypeInternal _PlayerAttributeMessage_WeaponsEntry_DoNotUse_default_instance_;
class PlayerStateMessage;
class PlayerStateMessageDefaultTypeInternal;
extern PlayerStateMessageDefaultTypeInternal _PlayerStateMessage_default_instance_;
class PlayerUpdateMessage;
class PlayerUpdateMessageDefaultTypeInternal;
extern PlayerUpdateMessageDefaultTypeInternal _PlayerUpdateMessage_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
namespace google {
namespace protobuf {
template<> ::HeartbeatMessage* Arena::CreateMaybeMessage<::HeartbeatMessage>(Arena*);
template<> ::NetworkMessage* Arena::CreateMaybeMessage<::NetworkMessage>(Arena*);
template<> ::PlayerAttributeMessage* Arena::CreateMaybeMessage<::PlayerAttributeMessage>(Arena*);
template<> ::PlayerAttributeMessage_AmmoEntry_DoNotUse* Arena::CreateMaybeMessage<::PlayerAttributeMessage_AmmoEntry_DoNotUse>(Arena*);
template<> ::PlayerAttributeMessage_WeaponsEntry_DoNotUse* Arena::CreateMaybeMessage<::PlayerAttributeMessage_WeaponsEntry_DoNotUse>(Arena*);
template<> ::PlayerStateMessage* Arena::CreateMaybeMessage<::PlayerStateMessage>(Arena*);
template<> ::PlayerUpdateMessage* Arena::CreateMaybeMessage<::PlayerUpdateMessage>(Arena*);
template<> ::Vector3* Arena::CreateMaybeMessage<::Vector3>(Arena*);
}  // namespace protobuf
}  // namespace google

enum MessageType {
  HEARTBEAT = 0,
  PLAYER_UPDATE = 1,
  PLAYER_ATTRIBUTE = 2,
  PLAYER_STATE = 3,
  PLAYER_JOIN = 4,
  PLAYER_LEAVE = 5,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = HEARTBEAT;
const MessageType MessageType_MAX = PLAYER_LEAVE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Vector3* other);
  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(NULL);
  }

  Vector3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NetworkMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerAttributeMessage_AmmoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PlayerAttributeMessage_AmmoEntry_DoNotUse, 
    ::std::string, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PlayerAttributeMessage_AmmoEntry_DoNotUse, 
    ::std::string, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  PlayerAttributeMessage_AmmoEntry_DoNotUse();
  PlayerAttributeMessage_AmmoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PlayerAttributeMessage_AmmoEntry_DoNotUse& other);
  static const PlayerAttributeMessage_AmmoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlayerAttributeMessage_AmmoEntry_DoNotUse*>(&_PlayerAttributeMessage_AmmoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PlayerAttributeMessage_WeaponsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PlayerAttributeMessage_WeaponsEntry_DoNotUse, 
    ::std::string, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PlayerAttributeMessage_WeaponsEntry_DoNotUse, 
    ::std::string, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  PlayerAttributeMessage_WeaponsEntry_DoNotUse();
  PlayerAttributeMessage_WeaponsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PlayerAttributeMessage_WeaponsEntry_DoNotUse& other);
  static const PlayerAttributeMessage_WeaponsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlayerAttributeMessage_WeaponsEntry_DoNotUse*>(&_PlayerAttributeMessage_WeaponsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PlayerAttributeMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerAttributeMessage) */ {
 public:
  PlayerAttributeMessage();
  virtual ~PlayerAttributeMessage();

  PlayerAttributeMessage(const PlayerAttributeMessage& from);

  inline PlayerAttributeMessage& operator=(const PlayerAttributeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerAttributeMessage(PlayerAttributeMessage&& from) noexcept
    : PlayerAttributeMessage() {
    *this = ::std::move(from);
  }

  inline PlayerAttributeMessage& operator=(PlayerAttributeMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAttributeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerAttributeMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerAttributeMessage*>(
               &_PlayerAttributeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PlayerAttributeMessage* other);
  friend void swap(PlayerAttributeMessage& a, PlayerAttributeMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerAttributeMessage* New() const final {
    return CreateMaybeMessage<PlayerAttributeMessage>(NULL);
  }

  PlayerAttributeMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerAttributeMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerAttributeMessage& from);
  void MergeFrom(const PlayerAttributeMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerAttributeMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, int32> ammo = 4;
  int ammo_size() const;
  void clear_ammo();
  static const int kAmmoFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
      ammo() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
      mutable_ammo();

  // map<string, int32> weapons = 5;
  int weapons_size() const;
  void clear_weapons();
  static const int kWeaponsFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
      weapons() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
      mutable_weapons();

  // uint32 player_id = 1;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // float health = 2;
  void clear_health();
  static const int kHealthFieldNumber = 2;
  float health() const;
  void set_health(float value);

  // float max_health = 3;
  void clear_max_health();
  static const int kMaxHealthFieldNumber = 3;
  float max_health() const;
  void set_max_health(float value);

  // float armor = 6;
  void clear_armor();
  static const int kArmorFieldNumber = 6;
  float armor() const;
  void set_armor(float value);

  // int32 score = 7;
  void clear_score();
  static const int kScoreFieldNumber = 7;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // int32 kills = 8;
  void clear_kills();
  static const int kKillsFieldNumber = 8;
  ::google::protobuf::int32 kills() const;
  void set_kills(::google::protobuf::int32 value);

  // int32 deaths = 9;
  void clear_deaths();
  static const int kDeathsFieldNumber = 9;
  ::google::protobuf::int32 deaths() const;
  void set_deaths(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerAttributeMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PlayerAttributeMessage_AmmoEntry_DoNotUse,
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > ammo_;
  ::google::protobuf::internal::MapField<
      PlayerAttributeMessage_WeaponsEntry_DoNotUse,
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > weapons_;
  ::google::protobuf::uint32 player_id_;
  float health_;
  float max_health_;
  float armor_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 kills_;
  ::google::protobuf::int32 deaths_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NetworkMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerStateMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerStateMessage) */ {
 public:
  PlayerStateMessage();
  virtual ~PlayerStateMessage();

  PlayerStateMessage(const PlayerStateMessage& from);

  inline PlayerStateMessage& operator=(const PlayerStateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerStateMessage(PlayerStateMessage&& from) noexcept
    : PlayerStateMessage() {
    *this = ::std::move(from);
  }

  inline PlayerStateMessage& operator=(PlayerStateMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerStateMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerStateMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerStateMessage*>(
               &_PlayerStateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PlayerStateMessage* other);
  friend void swap(PlayerStateMessage& a, PlayerStateMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerStateMessage* New() const final {
    return CreateMaybeMessage<PlayerStateMessage>(NULL);
  }

  PlayerStateMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerStateMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerStateMessage& from);
  void MergeFrom(const PlayerStateMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerStateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Vector3 position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  private:
  const ::Vector3& _internal_position() const;
  public:
  const ::Vector3& position() const;
  ::Vector3* release_position();
  ::Vector3* mutable_position();
  void set_allocated_position(::Vector3* position);

  // .Vector3 rotation = 3;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  private:
  const ::Vector3& _internal_rotation() const;
  public:
  const ::Vector3& rotation() const;
  ::Vector3* release_rotation();
  ::Vector3* mutable_rotation();
  void set_allocated_rotation(::Vector3* rotation);

  // .PlayerAttributeMessage attributes = 4;
  bool has_attributes() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  private:
  const ::PlayerAttributeMessage& _internal_attributes() const;
  public:
  const ::PlayerAttributeMessage& attributes() const;
  ::PlayerAttributeMessage* release_attributes();
  ::PlayerAttributeMessage* mutable_attributes();
  void set_allocated_attributes(::PlayerAttributeMessage* attributes);

  // uint32 player_id = 1;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // bool is_alive = 5;
  void clear_is_alive();
  static const int kIsAliveFieldNumber = 5;
  bool is_alive() const;
  void set_is_alive(bool value);

  // uint32 team_id = 6;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 6;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerStateMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vector3* position_;
  ::Vector3* rotation_;
  ::PlayerAttributeMessage* attributes_;
  ::google::protobuf::uint32 player_id_;
  bool is_alive_;
  ::google::protobuf::uint32 team_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NetworkMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HeartbeatMessage) */ {
 public:
  HeartbeatMessage();
  virtual ~HeartbeatMessage();

  HeartbeatMessage(const HeartbeatMessage& from);

  inline HeartbeatMessage& operator=(const HeartbeatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatMessage(HeartbeatMessage&& from) noexcept
    : HeartbeatMessage() {
    *this = ::std::move(from);
  }

  inline HeartbeatMessage& operator=(HeartbeatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatMessage* internal_default_instance() {
    return reinterpret_cast<const HeartbeatMessage*>(
               &_HeartbeatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(HeartbeatMessage* other);
  friend void swap(HeartbeatMessage& a, HeartbeatMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatMessage* New() const final {
    return CreateMaybeMessage<HeartbeatMessage>(NULL);
  }

  HeartbeatMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatMessage& from);
  void MergeFrom(const HeartbeatMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HeartbeatMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NetworkMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerUpdateMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerUpdateMessage) */ {
 public:
  PlayerUpdateMessage();
  virtual ~PlayerUpdateMessage();

  PlayerUpdateMessage(const PlayerUpdateMessage& from);

  inline PlayerUpdateMessage& operator=(const PlayerUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerUpdateMessage(PlayerUpdateMessage&& from) noexcept
    : PlayerUpdateMessage() {
    *this = ::std::move(from);
  }

  inline PlayerUpdateMessage& operator=(PlayerUpdateMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerUpdateMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerUpdateMessage*>(
               &_PlayerUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PlayerUpdateMessage* other);
  friend void swap(PlayerUpdateMessage& a, PlayerUpdateMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerUpdateMessage* New() const final {
    return CreateMaybeMessage<PlayerUpdateMessage>(NULL);
  }

  PlayerUpdateMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerUpdateMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerUpdateMessage& from);
  void MergeFrom(const PlayerUpdateMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerUpdateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float position_x = 1;
  void clear_position_x();
  static const int kPositionXFieldNumber = 1;
  float position_x() const;
  void set_position_x(float value);

  // float position_y = 2;
  void clear_position_y();
  static const int kPositionYFieldNumber = 2;
  float position_y() const;
  void set_position_y(float value);

  // float position_z = 3;
  void clear_position_z();
  static const int kPositionZFieldNumber = 3;
  float position_z() const;
  void set_position_z(float value);

  // float rotation_x = 4;
  void clear_rotation_x();
  static const int kRotationXFieldNumber = 4;
  float rotation_x() const;
  void set_rotation_x(float value);

  // float rotation_y = 5;
  void clear_rotation_y();
  static const int kRotationYFieldNumber = 5;
  float rotation_y() const;
  void set_rotation_y(float value);

  // float rotation_z = 6;
  void clear_rotation_z();
  static const int kRotationZFieldNumber = 6;
  float rotation_z() const;
  void set_rotation_z(float value);

  // float velocity_x = 7;
  void clear_velocity_x();
  static const int kVelocityXFieldNumber = 7;
  float velocity_x() const;
  void set_velocity_x(float value);

  // float velocity_y = 8;
  void clear_velocity_y();
  static const int kVelocityYFieldNumber = 8;
  float velocity_y() const;
  void set_velocity_y(float value);

  // float velocity_z = 9;
  void clear_velocity_z();
  static const int kVelocityZFieldNumber = 9;
  float velocity_z() const;
  void set_velocity_z(float value);

  // bool is_grounded = 10;
  void clear_is_grounded();
  static const int kIsGroundedFieldNumber = 10;
  bool is_grounded() const;
  void set_is_grounded(bool value);

  // float health = 11;
  void clear_health();
  static const int kHealthFieldNumber = 11;
  float health() const;
  void set_health(float value);

  // @@protoc_insertion_point(class_scope:PlayerUpdateMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float position_x_;
  float position_y_;
  float position_z_;
  float rotation_x_;
  float rotation_y_;
  float rotation_z_;
  float velocity_x_;
  float velocity_y_;
  float velocity_z_;
  bool is_grounded_;
  float health_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NetworkMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkMessage) */ {
 public:
  NetworkMessage();
  virtual ~NetworkMessage();

  NetworkMessage(const NetworkMessage& from);

  inline NetworkMessage& operator=(const NetworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkMessage(NetworkMessage&& from) noexcept
    : NetworkMessage() {
    *this = ::std::move(from);
  }

  inline NetworkMessage& operator=(NetworkMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkMessage& default_instance();

  enum DataCase {
    kHeartbeat = 4,
    kPlayerUpdate = 5,
    kPlayerAttribute = 6,
    kPlayerState = 7,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkMessage* internal_default_instance() {
    return reinterpret_cast<const NetworkMessage*>(
               &_NetworkMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NetworkMessage* other);
  friend void swap(NetworkMessage& a, NetworkMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkMessage* New() const final {
    return CreateMaybeMessage<NetworkMessage>(NULL);
  }

  NetworkMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetworkMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NetworkMessage& from);
  void MergeFrom(const NetworkMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .MessageType msg_id = 1;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  ::MessageType msg_id() const;
  void set_msg_id(::MessageType value);

  // uint32 player_id = 2;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // uint32 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // .HeartbeatMessage heartbeat = 4;
  bool has_heartbeat() const;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 4;
  private:
  const ::HeartbeatMessage& _internal_heartbeat() const;
  public:
  const ::HeartbeatMessage& heartbeat() const;
  ::HeartbeatMessage* release_heartbeat();
  ::HeartbeatMessage* mutable_heartbeat();
  void set_allocated_heartbeat(::HeartbeatMessage* heartbeat);

  // .PlayerUpdateMessage player_update = 5;
  bool has_player_update() const;
  void clear_player_update();
  static const int kPlayerUpdateFieldNumber = 5;
  private:
  const ::PlayerUpdateMessage& _internal_player_update() const;
  public:
  const ::PlayerUpdateMessage& player_update() const;
  ::PlayerUpdateMessage* release_player_update();
  ::PlayerUpdateMessage* mutable_player_update();
  void set_allocated_player_update(::PlayerUpdateMessage* player_update);

  // .PlayerAttributeMessage player_attribute = 6;
  bool has_player_attribute() const;
  void clear_player_attribute();
  static const int kPlayerAttributeFieldNumber = 6;
  private:
  const ::PlayerAttributeMessage& _internal_player_attribute() const;
  public:
  const ::PlayerAttributeMessage& player_attribute() const;
  ::PlayerAttributeMessage* release_player_attribute();
  ::PlayerAttributeMessage* mutable_player_attribute();
  void set_allocated_player_attribute(::PlayerAttributeMessage* player_attribute);

  // .PlayerStateMessage player_state = 7;
  bool has_player_state() const;
  void clear_player_state();
  static const int kPlayerStateFieldNumber = 7;
  private:
  const ::PlayerStateMessage& _internal_player_state() const;
  public:
  const ::PlayerStateMessage& player_state() const;
  ::PlayerStateMessage* release_player_state();
  ::PlayerStateMessage* mutable_player_state();
  void set_allocated_player_state(::PlayerStateMessage* player_state);

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:NetworkMessage)
 private:
  void set_has_heartbeat();
  void set_has_player_update();
  void set_has_player_attribute();
  void set_has_player_state();

  inline bool has_data() const;
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int msg_id_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 timestamp_;
  union DataUnion {
    DataUnion() {}
    ::HeartbeatMessage* heartbeat_;
    ::PlayerUpdateMessage* player_update_;
    ::PlayerAttributeMessage* player_attribute_;
    ::PlayerStateMessage* player_state_;
  } data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_NetworkMessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector3.z)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlayerAttributeMessage

// uint32 player_id = 1;
inline void PlayerAttributeMessage::clear_player_id() {
  player_id_ = 0u;
}
inline ::google::protobuf::uint32 PlayerAttributeMessage::player_id() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.player_id)
  return player_id_;
}
inline void PlayerAttributeMessage::set_player_id(::google::protobuf::uint32 value) {
  
  player_id_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.player_id)
}

// float health = 2;
inline void PlayerAttributeMessage::clear_health() {
  health_ = 0;
}
inline float PlayerAttributeMessage::health() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.health)
  return health_;
}
inline void PlayerAttributeMessage::set_health(float value) {
  
  health_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.health)
}

// float max_health = 3;
inline void PlayerAttributeMessage::clear_max_health() {
  max_health_ = 0;
}
inline float PlayerAttributeMessage::max_health() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.max_health)
  return max_health_;
}
inline void PlayerAttributeMessage::set_max_health(float value) {
  
  max_health_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.max_health)
}

// map<string, int32> ammo = 4;
inline int PlayerAttributeMessage::ammo_size() const {
  return ammo_.size();
}
inline void PlayerAttributeMessage::clear_ammo() {
  ammo_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
PlayerAttributeMessage::ammo() const {
  // @@protoc_insertion_point(field_map:PlayerAttributeMessage.ammo)
  return ammo_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
PlayerAttributeMessage::mutable_ammo() {
  // @@protoc_insertion_point(field_mutable_map:PlayerAttributeMessage.ammo)
  return ammo_.MutableMap();
}

// map<string, int32> weapons = 5;
inline int PlayerAttributeMessage::weapons_size() const {
  return weapons_.size();
}
inline void PlayerAttributeMessage::clear_weapons() {
  weapons_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
PlayerAttributeMessage::weapons() const {
  // @@protoc_insertion_point(field_map:PlayerAttributeMessage.weapons)
  return weapons_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
PlayerAttributeMessage::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_map:PlayerAttributeMessage.weapons)
  return weapons_.MutableMap();
}

// float armor = 6;
inline void PlayerAttributeMessage::clear_armor() {
  armor_ = 0;
}
inline float PlayerAttributeMessage::armor() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.armor)
  return armor_;
}
inline void PlayerAttributeMessage::set_armor(float value) {
  
  armor_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.armor)
}

// int32 score = 7;
inline void PlayerAttributeMessage::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 PlayerAttributeMessage::score() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.score)
  return score_;
}
inline void PlayerAttributeMessage::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.score)
}

// int32 kills = 8;
inline void PlayerAttributeMessage::clear_kills() {
  kills_ = 0;
}
inline ::google::protobuf::int32 PlayerAttributeMessage::kills() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.kills)
  return kills_;
}
inline void PlayerAttributeMessage::set_kills(::google::protobuf::int32 value) {
  
  kills_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.kills)
}

// int32 deaths = 9;
inline void PlayerAttributeMessage::clear_deaths() {
  deaths_ = 0;
}
inline ::google::protobuf::int32 PlayerAttributeMessage::deaths() const {
  // @@protoc_insertion_point(field_get:PlayerAttributeMessage.deaths)
  return deaths_;
}
inline void PlayerAttributeMessage::set_deaths(::google::protobuf::int32 value) {
  
  deaths_ = value;
  // @@protoc_insertion_point(field_set:PlayerAttributeMessage.deaths)
}

// -------------------------------------------------------------------

// PlayerStateMessage

// uint32 player_id = 1;
inline void PlayerStateMessage::clear_player_id() {
  player_id_ = 0u;
}
inline ::google::protobuf::uint32 PlayerStateMessage::player_id() const {
  // @@protoc_insertion_point(field_get:PlayerStateMessage.player_id)
  return player_id_;
}
inline void PlayerStateMessage::set_player_id(::google::protobuf::uint32 value) {
  
  player_id_ = value;
  // @@protoc_insertion_point(field_set:PlayerStateMessage.player_id)
}

// .Vector3 position = 2;
inline bool PlayerStateMessage::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void PlayerStateMessage::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Vector3& PlayerStateMessage::_internal_position() const {
  return *position_;
}
inline const ::Vector3& PlayerStateMessage::position() const {
  const ::Vector3* p = position_;
  // @@protoc_insertion_point(field_get:PlayerStateMessage.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* PlayerStateMessage::release_position() {
  // @@protoc_insertion_point(field_release:PlayerStateMessage.position)
  
  ::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Vector3* PlayerStateMessage::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PlayerStateMessage.position)
  return position_;
}
inline void PlayerStateMessage::set_allocated_position(::Vector3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:PlayerStateMessage.position)
}

// .Vector3 rotation = 3;
inline bool PlayerStateMessage::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void PlayerStateMessage::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) {
    delete rotation_;
  }
  rotation_ = NULL;
}
inline const ::Vector3& PlayerStateMessage::_internal_rotation() const {
  return *rotation_;
}
inline const ::Vector3& PlayerStateMessage::rotation() const {
  const ::Vector3* p = rotation_;
  // @@protoc_insertion_point(field_get:PlayerStateMessage.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* PlayerStateMessage::release_rotation() {
  // @@protoc_insertion_point(field_release:PlayerStateMessage.rotation)
  
  ::Vector3* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::Vector3* PlayerStateMessage::mutable_rotation() {
  
  if (rotation_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PlayerStateMessage.rotation)
  return rotation_;
}
inline void PlayerStateMessage::set_allocated_rotation(::Vector3* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:PlayerStateMessage.rotation)
}

// .PlayerAttributeMessage attributes = 4;
inline bool PlayerStateMessage::has_attributes() const {
  return this != internal_default_instance() && attributes_ != NULL;
}
inline void PlayerStateMessage::clear_attributes() {
  if (GetArenaNoVirtual() == NULL && attributes_ != NULL) {
    delete attributes_;
  }
  attributes_ = NULL;
}
inline const ::PlayerAttributeMessage& PlayerStateMessage::_internal_attributes() const {
  return *attributes_;
}
inline const ::PlayerAttributeMessage& PlayerStateMessage::attributes() const {
  const ::PlayerAttributeMessage* p = attributes_;
  // @@protoc_insertion_point(field_get:PlayerStateMessage.attributes)
  return p != NULL ? *p : *reinterpret_cast<const ::PlayerAttributeMessage*>(
      &::_PlayerAttributeMessage_default_instance_);
}
inline ::PlayerAttributeMessage* PlayerStateMessage::release_attributes() {
  // @@protoc_insertion_point(field_release:PlayerStateMessage.attributes)
  
  ::PlayerAttributeMessage* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline ::PlayerAttributeMessage* PlayerStateMessage::mutable_attributes() {
  
  if (attributes_ == NULL) {
    auto* p = CreateMaybeMessage<::PlayerAttributeMessage>(GetArenaNoVirtual());
    attributes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PlayerStateMessage.attributes)
  return attributes_;
}
inline void PlayerStateMessage::set_allocated_attributes(::PlayerAttributeMessage* attributes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attributes_;
  }
  if (attributes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attributes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:PlayerStateMessage.attributes)
}

// bool is_alive = 5;
inline void PlayerStateMessage::clear_is_alive() {
  is_alive_ = false;
}
inline bool PlayerStateMessage::is_alive() const {
  // @@protoc_insertion_point(field_get:PlayerStateMessage.is_alive)
  return is_alive_;
}
inline void PlayerStateMessage::set_is_alive(bool value) {
  
  is_alive_ = value;
  // @@protoc_insertion_point(field_set:PlayerStateMessage.is_alive)
}

// uint32 team_id = 6;
inline void PlayerStateMessage::clear_team_id() {
  team_id_ = 0u;
}
inline ::google::protobuf::uint32 PlayerStateMessage::team_id() const {
  // @@protoc_insertion_point(field_get:PlayerStateMessage.team_id)
  return team_id_;
}
inline void PlayerStateMessage::set_team_id(::google::protobuf::uint32 value) {
  
  team_id_ = value;
  // @@protoc_insertion_point(field_set:PlayerStateMessage.team_id)
}

// -------------------------------------------------------------------

// HeartbeatMessage

// -------------------------------------------------------------------

// PlayerUpdateMessage

// float position_x = 1;
inline void PlayerUpdateMessage::clear_position_x() {
  position_x_ = 0;
}
inline float PlayerUpdateMessage::position_x() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.position_x)
  return position_x_;
}
inline void PlayerUpdateMessage::set_position_x(float value) {
  
  position_x_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.position_x)
}

// float position_y = 2;
inline void PlayerUpdateMessage::clear_position_y() {
  position_y_ = 0;
}
inline float PlayerUpdateMessage::position_y() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.position_y)
  return position_y_;
}
inline void PlayerUpdateMessage::set_position_y(float value) {
  
  position_y_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.position_y)
}

// float position_z = 3;
inline void PlayerUpdateMessage::clear_position_z() {
  position_z_ = 0;
}
inline float PlayerUpdateMessage::position_z() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.position_z)
  return position_z_;
}
inline void PlayerUpdateMessage::set_position_z(float value) {
  
  position_z_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.position_z)
}

// float rotation_x = 4;
inline void PlayerUpdateMessage::clear_rotation_x() {
  rotation_x_ = 0;
}
inline float PlayerUpdateMessage::rotation_x() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.rotation_x)
  return rotation_x_;
}
inline void PlayerUpdateMessage::set_rotation_x(float value) {
  
  rotation_x_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.rotation_x)
}

// float rotation_y = 5;
inline void PlayerUpdateMessage::clear_rotation_y() {
  rotation_y_ = 0;
}
inline float PlayerUpdateMessage::rotation_y() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.rotation_y)
  return rotation_y_;
}
inline void PlayerUpdateMessage::set_rotation_y(float value) {
  
  rotation_y_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.rotation_y)
}

// float rotation_z = 6;
inline void PlayerUpdateMessage::clear_rotation_z() {
  rotation_z_ = 0;
}
inline float PlayerUpdateMessage::rotation_z() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.rotation_z)
  return rotation_z_;
}
inline void PlayerUpdateMessage::set_rotation_z(float value) {
  
  rotation_z_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.rotation_z)
}

// float velocity_x = 7;
inline void PlayerUpdateMessage::clear_velocity_x() {
  velocity_x_ = 0;
}
inline float PlayerUpdateMessage::velocity_x() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.velocity_x)
  return velocity_x_;
}
inline void PlayerUpdateMessage::set_velocity_x(float value) {
  
  velocity_x_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.velocity_x)
}

// float velocity_y = 8;
inline void PlayerUpdateMessage::clear_velocity_y() {
  velocity_y_ = 0;
}
inline float PlayerUpdateMessage::velocity_y() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.velocity_y)
  return velocity_y_;
}
inline void PlayerUpdateMessage::set_velocity_y(float value) {
  
  velocity_y_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.velocity_y)
}

// float velocity_z = 9;
inline void PlayerUpdateMessage::clear_velocity_z() {
  velocity_z_ = 0;
}
inline float PlayerUpdateMessage::velocity_z() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.velocity_z)
  return velocity_z_;
}
inline void PlayerUpdateMessage::set_velocity_z(float value) {
  
  velocity_z_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.velocity_z)
}

// bool is_grounded = 10;
inline void PlayerUpdateMessage::clear_is_grounded() {
  is_grounded_ = false;
}
inline bool PlayerUpdateMessage::is_grounded() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.is_grounded)
  return is_grounded_;
}
inline void PlayerUpdateMessage::set_is_grounded(bool value) {
  
  is_grounded_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.is_grounded)
}

// float health = 11;
inline void PlayerUpdateMessage::clear_health() {
  health_ = 0;
}
inline float PlayerUpdateMessage::health() const {
  // @@protoc_insertion_point(field_get:PlayerUpdateMessage.health)
  return health_;
}
inline void PlayerUpdateMessage::set_health(float value) {
  
  health_ = value;
  // @@protoc_insertion_point(field_set:PlayerUpdateMessage.health)
}

// -------------------------------------------------------------------

// NetworkMessage

// .MessageType msg_id = 1;
inline void NetworkMessage::clear_msg_id() {
  msg_id_ = 0;
}
inline ::MessageType NetworkMessage::msg_id() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.msg_id)
  return static_cast< ::MessageType >(msg_id_);
}
inline void NetworkMessage::set_msg_id(::MessageType value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkMessage.msg_id)
}

// uint32 player_id = 2;
inline void NetworkMessage::clear_player_id() {
  player_id_ = 0u;
}
inline ::google::protobuf::uint32 NetworkMessage::player_id() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.player_id)
  return player_id_;
}
inline void NetworkMessage::set_player_id(::google::protobuf::uint32 value) {
  
  player_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkMessage.player_id)
}

// uint32 timestamp = 3;
inline void NetworkMessage::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::google::protobuf::uint32 NetworkMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.timestamp)
  return timestamp_;
}
inline void NetworkMessage::set_timestamp(::google::protobuf::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:NetworkMessage.timestamp)
}

// .HeartbeatMessage heartbeat = 4;
inline bool NetworkMessage::has_heartbeat() const {
  return data_case() == kHeartbeat;
}
inline void NetworkMessage::set_has_heartbeat() {
  _oneof_case_[0] = kHeartbeat;
}
inline void NetworkMessage::clear_heartbeat() {
  if (has_heartbeat()) {
    delete data_.heartbeat_;
    clear_has_data();
  }
}
inline const ::HeartbeatMessage& NetworkMessage::_internal_heartbeat() const {
  return *data_.heartbeat_;
}
inline ::HeartbeatMessage* NetworkMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:NetworkMessage.heartbeat)
  if (has_heartbeat()) {
    clear_has_data();
      ::HeartbeatMessage* temp = data_.heartbeat_;
    data_.heartbeat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::HeartbeatMessage& NetworkMessage::heartbeat() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.heartbeat)
  return has_heartbeat()
      ? *data_.heartbeat_
      : *reinterpret_cast< ::HeartbeatMessage*>(&::_HeartbeatMessage_default_instance_);
}
inline ::HeartbeatMessage* NetworkMessage::mutable_heartbeat() {
  if (!has_heartbeat()) {
    clear_data();
    set_has_heartbeat();
    data_.heartbeat_ = CreateMaybeMessage< ::HeartbeatMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:NetworkMessage.heartbeat)
  return data_.heartbeat_;
}

// .PlayerUpdateMessage player_update = 5;
inline bool NetworkMessage::has_player_update() const {
  return data_case() == kPlayerUpdate;
}
inline void NetworkMessage::set_has_player_update() {
  _oneof_case_[0] = kPlayerUpdate;
}
inline void NetworkMessage::clear_player_update() {
  if (has_player_update()) {
    delete data_.player_update_;
    clear_has_data();
  }
}
inline const ::PlayerUpdateMessage& NetworkMessage::_internal_player_update() const {
  return *data_.player_update_;
}
inline ::PlayerUpdateMessage* NetworkMessage::release_player_update() {
  // @@protoc_insertion_point(field_release:NetworkMessage.player_update)
  if (has_player_update()) {
    clear_has_data();
      ::PlayerUpdateMessage* temp = data_.player_update_;
    data_.player_update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PlayerUpdateMessage& NetworkMessage::player_update() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.player_update)
  return has_player_update()
      ? *data_.player_update_
      : *reinterpret_cast< ::PlayerUpdateMessage*>(&::_PlayerUpdateMessage_default_instance_);
}
inline ::PlayerUpdateMessage* NetworkMessage::mutable_player_update() {
  if (!has_player_update()) {
    clear_data();
    set_has_player_update();
    data_.player_update_ = CreateMaybeMessage< ::PlayerUpdateMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:NetworkMessage.player_update)
  return data_.player_update_;
}

// .PlayerAttributeMessage player_attribute = 6;
inline bool NetworkMessage::has_player_attribute() const {
  return data_case() == kPlayerAttribute;
}
inline void NetworkMessage::set_has_player_attribute() {
  _oneof_case_[0] = kPlayerAttribute;
}
inline void NetworkMessage::clear_player_attribute() {
  if (has_player_attribute()) {
    delete data_.player_attribute_;
    clear_has_data();
  }
}
inline const ::PlayerAttributeMessage& NetworkMessage::_internal_player_attribute() const {
  return *data_.player_attribute_;
}
inline ::PlayerAttributeMessage* NetworkMessage::release_player_attribute() {
  // @@protoc_insertion_point(field_release:NetworkMessage.player_attribute)
  if (has_player_attribute()) {
    clear_has_data();
      ::PlayerAttributeMessage* temp = data_.player_attribute_;
    data_.player_attribute_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PlayerAttributeMessage& NetworkMessage::player_attribute() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.player_attribute)
  return has_player_attribute()
      ? *data_.player_attribute_
      : *reinterpret_cast< ::PlayerAttributeMessage*>(&::_PlayerAttributeMessage_default_instance_);
}
inline ::PlayerAttributeMessage* NetworkMessage::mutable_player_attribute() {
  if (!has_player_attribute()) {
    clear_data();
    set_has_player_attribute();
    data_.player_attribute_ = CreateMaybeMessage< ::PlayerAttributeMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:NetworkMessage.player_attribute)
  return data_.player_attribute_;
}

// .PlayerStateMessage player_state = 7;
inline bool NetworkMessage::has_player_state() const {
  return data_case() == kPlayerState;
}
inline void NetworkMessage::set_has_player_state() {
  _oneof_case_[0] = kPlayerState;
}
inline void NetworkMessage::clear_player_state() {
  if (has_player_state()) {
    delete data_.player_state_;
    clear_has_data();
  }
}
inline const ::PlayerStateMessage& NetworkMessage::_internal_player_state() const {
  return *data_.player_state_;
}
inline ::PlayerStateMessage* NetworkMessage::release_player_state() {
  // @@protoc_insertion_point(field_release:NetworkMessage.player_state)
  if (has_player_state()) {
    clear_has_data();
      ::PlayerStateMessage* temp = data_.player_state_;
    data_.player_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PlayerStateMessage& NetworkMessage::player_state() const {
  // @@protoc_insertion_point(field_get:NetworkMessage.player_state)
  return has_player_state()
      ? *data_.player_state_
      : *reinterpret_cast< ::PlayerStateMessage*>(&::_PlayerStateMessage_default_instance_);
}
inline ::PlayerStateMessage* NetworkMessage::mutable_player_state() {
  if (!has_player_state()) {
    clear_data();
    set_has_player_state();
    data_.player_state_ = CreateMaybeMessage< ::PlayerStateMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:NetworkMessage.player_state)
  return data_.player_state_;
}

inline bool NetworkMessage::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void NetworkMessage::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline NetworkMessage::DataCase NetworkMessage::data_case() const {
  return NetworkMessage::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_NetworkMessage_2eproto
